                        UNIVERSAL GAME ENGINE INTERFACE
                                 November 2018

                                    Preamble

 The UCI protocol has been the de-facto standard for chess software since its
introduction in November 2000. It has enjoyed tremendous success and hundreds
of chess engines support it despite its limitations. With this revision I
aspire to:

 a) Define a new open protocol for all kinds of turn-based strategy games. Its
    core data model will be a portable game format that integrates well with the
    APIs.
 b) Foster collaboration between engine developers across all game communities.
    By adopting a single standard, everyone can benefit from better GUI support
    and tooling. There is no such standard at the moment and I hope that UGEI
    can fill that niche.
 c) Always mantain full backwards compatibility. New features will never break
    existing engines.

                                  Conventions

 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119.

 The "Engine Progam" means the software that implements game logic and AI
capabilities.
 The "Client" means the software that communicates with the Engine Program and
provides a game interface for the end user.
 To "search" means to perform some calculations to achieve better play. Ideally,
searching ad infinitum will converge to perfect play.
 A "move" means the smallest atomic event worthy of notice during a game. A
sequence of moves forms a player's turn; a sequence of players' turns forms a
whole game. For example, chess and Go only allow one move per player turn,
while Risk and draughts allow many more.

 Lines in this document with a three spaces indentation give examples of
Client and Engine Program communication. The "greater-than" symbol prepends all
messages from the Client to the Engine Program; similarly, the "greater-then"
symbol prepends all messages from the Engine Program to the Client. E.g.

   > Client to Engine program
   < Engine Program to Client

 This document uses JSON Schema to detail JSON APIs. Square brackets (ASCII
91 and 93) in body text indicate JSON values. E.g. [42], ["spam"], [null].

                                    Overview

 UGEI supports communication between two pieces of software - the Engine
Program and the Client - over JSON-RPC 2.0 messages. The Engine Program MUST
read and, if necessary, reply to all incoming messages for its whole lifetime.
The Engine Program, being the Server, MUST accept Request objects even when
searching.
 Th
 The Engine Program SHOULD read incoming messages from standard input and
SHOULD write outgoing messages from standard output. The UGEI standard is transport-agnostic and is not command-line specific

 * MUST each be terminated by a (CR)LF byte sequence.
 * MUST NOT contain 
 * SHOULD be minified for better performance.

 Optionally, the Engine Program MAY also output lines that start with a number
sign (ASCII 35) and serve other purposes, such as logging or debugging
messages. The Client MUST ignore such messages.

   < # The Client MUST ignore this line.

The JSON data models are transport-agnostic and can also 
storage on disk or download.

{
    "definitions" : {
    "game_record": {
          "type": "object",
          "properties": {
              "ruleset": {
                  "type": "string",
              },
              "time_control": {
                "type": "array",
                "items": { "$ref": "#/definitions/time_control" }
            },
              "result": {
                  "type": "array",
                  "items": {
                      "type": "number"
                  },
                "description": "A list of points given or retracted from player's records."
              },
              "termination": {
                  "enum": [
                    null,
                      "normal",
                      "agreement",
                      "adjudication",
                      "claim",
                      "flagging",
                      "emergency",
                      "other",
                  ],
              },
            "players_count": {
                "type": "integer",
                "$comment": "REQUIRED if the ruleset allows a range of players"
            },
              "history": {
                "type": "array",
              },
              "meta": {
                  "type": "object",
                  "properties": {
                      "about": { "type": "string" },
                      "event": { "type": "string" },
                      "site": { "type": "string" },
                      "round": { "type": "integer" },
                      "annotator": { "type": "string" },
                      "date": { "type": "date-time" },
                       "players": {
                           "type": "array",
                           "items": { "$ref": "#/definitions/player" }
                       }
                  }
            }
        },
        "required": ["ruleset"]
    }

    {
        "player": {
            "type": "object",
            "properties": {
                "name": { "type": "string" },
                "elo": { "type": "number" },
                "rank": { "type": "string" },
                "team": { "type": "string" }
            },
            "examples": [{
                "name": "Boris Vasilievich Spassky",
                "elo": 2625,
                "team": "Russia"
            }, {
                "name": "Go Seigen",
                "rank": "9 dan",
                "team": "Republic of China"
            }]
        }
    }

    {
        "time_control": {
            "type": "object",
            "properties": {
                "time_limit": {
                    "type": "number"
                },
                   "increment": {
                    "type": "number",
                    "default": 0
                },
                   "delay": {
                    "type": "number",
                    "default": 0
                },
                   "overtime": {
                    "$ref": "#/definitions/time_control"
                },
                   "next_time_control": {
                    "$ref": "#/definitions/time_control"
                },
                   "trigger": {}
            },
            "required": ["time_limit"]
        }
    }

                                    ["init"]

 The Client MUST initialize the Engine Program by sending a `init` Request before
any other message. Upon receiving the Request, the Engine Program MAY perform
expensive one-time operations such as copy protection check or reading support
files into memory. After initialization, the Response object MAY include
metainformation.

 The `init` Method does not require any Parameters.

    {
        "$id": "#/methods/init/result",
        "type": "object",
        "properties": {
            "meta": {
                "type": "object",
                "properties": {
                    "copyright": { "type": "string" },
                    "compiler": { "type": "string" },
                    "elo": { "type": "number" },
                    "license": { "type": "string" },
                    "name": { "type": "string" },
                    "rank": { "type": "string" },
                    "release_date": { "type": "date-time" },
                    "url": { "type": "uri" },
                    "version": { "type": "string" },
                }
            },
            "rulesets": {
                "type": "array",
                "items": { "$ref": "#/definitions/ruleset" }
            }
        },
        "required": ["rulesets"]
    }

    {
        "$id": "#/definitions/ruleset",
        "type": "string",
        "enum": [
              "chess",
              "chesslosing"
              "chesskingofthehill",
              "go",
              "shogi"
        ]
    }

                                    ["exit"]

 Before killing the Engine Program, the Client SHOULD send an `exit` Request.
The Engine Program SHOULD then send an empty Response and exit gracefully. This
Method does not require any Parameters.

                                   ["config"]

This method allows the GUI program to tune engine parameters.

    {
        "$id": "#/methods/config/params",
        "type": "object",
        "properties": {
            "key": { "type": "string" },
            "value": {}
        },
        "required": ["key", "value"]
    }

                                   [ setup ]

    {
        "$id": "#/methods/setup/params",
        "$ref": "#/definitions/game_record"
    }

                                  [ refresh ]

Updates the game record with new available information.

{
    "properties": {
        "elapsed_time": { "type": "number" },
        "moves": {}
    }
}

                                   [ status ]

    {
        "$id": "#/methods/status/params",
        "type": "object"
    }

    {
        "$id": "#/methods/status/result",
        "type": "object"
    }

Clients MAY send "status" requests at any time to check for freezing or
latency. This method doesn't have any parameters or result.

               Examples of Client-to-Engine-Program communication

 The ["jsonrpc"] property is omitted for brevity. You should always use it for
real world IPC.

   > {"method": "init","id":0}
   < {"id":0}
            "result": {
                "meta": {
                    "name": "Foobar",
                    "url": "https://foo.bar"
                }
            },
            "id": 0
        }

    --> {
            "method": "setup",
            "params": {
                "ruleset": "risk",
                "setup": {
                    "side-to-move": 0,
                    "sides": [{
                        "troops": {
                            "Russia": 2,
                            "Kamchatka": 6,
                            "Alaska": 3,
                            ...
                        },
                        "cards": [{
                            "territory": "Russia",
                            "symbol": "cavalry"
                        }]
                    }, {
                        ...
                    }]
                }
            },
            "id": 1
        }
    <-- { "id": 1 }

    --> {
            "method": "search",
            "params": {
                "notifications": true
            },
            "id": 3
        }
    <-- {
            "method": "#search",
            "result": {},
            "id": 3
        }
    <-- {"method": "#search", "result": {}, "id": 3}
    <-- {"method": "#search", "result": {}, "id": 3}
    <-- {"method": "#search", "result": {}, "id": 3}
    <-- {"method": "stop", "id": 3}

                                     Errors

 * 0: "Generic error"
20-49: hardware or system problems
 * 20: "Unsupported OS or device" (at init)
 * 21: "OOM condition"
 * 22: "Unknown error"
50-64: proprietary stuff
 * 50: "Copy protection error" (at init)
 * 51: "Feature not available"
900-999: unsupported but valid
 * 900: "Unsupported ruleset"
 * 901: "Unorthodox time format"
 * 902: "Undefined key"
1000-1399: game-specific errors
 * 1000: "Invalid game logic"

                            A note on extensibility

UGEI is designed with this use case in mind.

The UGEI specification is designed to be a versatile interface to chess software and doesn't only support the engine/GUI model.
You may find UGEI useful for:

  The 'get' method retrieves the value of a certain variable.

  - "tablebase:format"
    The format of the tablebase that 'tablbase:path' points to. Common formats are:
    - "Nalimov"
    - "Syzgi"
    - "Lomonosov"
    - "Gaviota"
  - "tablebase:path"
    A filepath that points to tablebases.

'game:board:fen'
    'game:history'
    'game:pgn'
    'game:result'
    'game:variant'
    'clock'
    'eval:best-move'
    'eval:best-lines'
    'eval:drawishness'
    'eval:mate'
    'settings:cache-size'
    'settings:resign-rate'
    'settings:resoluteness'
    'settings:sharpness'

2.4 'status'
    Clients MAY send requests with the 'status' method to check on the engine
    and make sure it's not frozen.

2.6 'setup'
    Clients setup the game state using this method. Every request SHOULD reset
    all previous knowledge about the position.

2.7 'go-to'
    Go to a specific position while being in the same game.

3. Example of client and server communication over stdin/stdout
---------------------------------------------------------------

Implementing UGEI is very easy and requires less code than UCI. UCI
implementations require a custom parser and tokenized, but with UGEI you can
use a library such as cJSON or Modern C++.

                              Links and resources

* JSON-RPC 2.0 specification.
  <https://www.jsonrpc.org/specification>
* First draft of the UCI protocol.
  <http://wbec-ridderkerk.nl/html/UCIProtocol.html>
* JSON Schema project webpage.
  <https://json-schema.org/>
* Relevant XKCD
  <https://xkcd.com/927/>
